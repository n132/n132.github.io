---
title: "Introduction of Kernel Exploitations"
date: 2022-05-16 19:09:21
tags: 
layout: default
---
# Prilogue
I only have little experience about kernel and kernel pwn. During the `Intro_to_OS` course, I read a lot kernel code of `xv6` and learned the kernel systematically. Algough, `xv6` is a simple system while the `linux` kernel is much more complex, the knowledge from `xv6` learned helps a lot.

This post would not go too deep in the kernel because I am too weak to do that and I got all the solution ideas from `ctf-wiki`. You can also download the attachments at this [link][1]
# Stack Overflow

In kernel, we also have stack overflow. But the exploitation is a little different from in user mode. There are kinds of countermeasures in kernel, such as `kaslr`, `smep`, `smap`. Besides, we need to come back to user mode after perform privilege eascaping. 

I'll start from a simple challenge and go through the expoit script to demostrate the steps in kernel exploitation. You can get the attachment at this [link][2].

## Kernel-ROP:2018-QWB-Core
For kernel challenge, we would like to start from the boot script, `start.sh`.
```sh
qemu-system-x86_64 \
-m 2G \
-kernel ./bzImage \
-initrd  ./core.cpio \
-append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr" \
-s  \
-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \
-nographic  

```

> Tips: Sometimes you need to change the memory limit for qemu vm to run the qemu vm, such as `-m 2G`

> Tips: If there are multi-cores, this challenge may be related to the race condition.

In this challenge on only have `kaslr`, which means there is no `smap` and `smep`. During the debugging, we can modify the boot script to trun of the kaslr(`... quiet nokaslr"`).

And I would check the `init` script in the file system.

```sh
#!/bin/sh
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t devtmpfs none /dev
/sbin/mdev -s
mkdir -p /dev/pts
mount -vt devpts -o gid=4,mode=620 none /dev/pts
chmod 666 /dev/ptmx
cat /proc/kallsyms > /tmp/kallsyms
echo 1 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict
ifconfig eth0 up
udhcpc -i eth0
ifconfig eth0 10.0.2.15 netmask 255.255.255.0
route add default gw 10.0.2.2 
insmod /core.ko

setsid /bin/cttyhack setuidgid 1000 /bin/sh
echo 'sh end!\n'
umount /proc
umount /sys

poweroff -d 0  -f
```

It's also a script, which init the setting of challenge eviroment. As we can see, we can't read the symbol address in `/proc/kallsyms` and use `dmesg` to debug. However, all the symbols are copyied in `/tmp/kallsyms`(Line 9). Also, you can comment line 10-11 and change uid at line 18 to 0 while debugging.

After reviewing these scripts, we can start the reversing. There is nothing important in `init_module` and `exit_core` while in `core_ioctl` we have three functions. 

```c
__int64 __fastcall core_copy_func(__int64 a1)
{
  __int64 result; // rax
  _QWORD v2[10]; // [rsp+0h] [rbp-50h] BYREF

  v2[8] = __readgsqword(0x28u);
  printk(&ss1);
  if ( a1 > 63 )
  {
    printk(&unk_2A1);
    return 0xFFFFFFFFLL;
  }
  else
  {
    result = 0LL;
    qmemcpy(v2, &name, (unsigned __int16)a1);
  }
  return result;
}
__int64 __fastcall core_write(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  printk(&ss1);
  if ( a3 <= 0x800 && !copy_from_user(&name, a2, a3) )
    return (unsigned int)a3;
  printk(&ss2);
  return 4294967282LL;
}
```

The most important two functions are `core_copy_func` and `core_write`. We can use `write(fd,buf,0x800)` to fill the buffer `name` and use `core_copy_func` to trigger the buffer overflow because the buffer length is only 0x10 and we could at most have 0x800 bytes in `name`.

The solution is simialr to the user space bof challenge's.
- use `write` to copy the payload to the kernel space
- use `ioctl` to call `core_copy_func` to trigger the buffer overflow
- control RIP to perform later attacking





# Use after Free


# 


[1]: xxx
[2]: 